<!DOCTYPE html>
<html lang="sr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradient Descent sa Momentumom</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            color: #2d3748;
            text-align: center;
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: #718096;
            margin-bottom: 30px;
        }

        .content {
            display: grid;
            grid-template-columns: 800px 1fr;
            gap: 30px;
        }

        .canvas-container {
            position: relative;
        }

        canvas {
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            cursor: crosshair;
            display: block;
        }

        .controls {
            background: #f7fafc;
            padding: 20px;
            border-radius: 10px;
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 8px;
        }

        .control-group select,
        .control-group input[type="range"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #cbd5e0;
            border-radius: 5px;
            font-size: 14px;
        }

        .control-group input[type="range"] {
            padding: 0;
        }

        .value-display {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 13px;
            margin-left: 10px;
            min-width: 60px;
            text-align: center;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-start {
            background: #48bb78;
            color: white;
        }

        .btn-start:hover {
            background: #38a169;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(72, 187, 120, 0.4);
        }

        .btn-stop {
            background: #f56565;
            color: white;
        }

        .btn-stop:hover {
            background: #e53e3e;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(245, 101, 101, 0.4);
        }

        .btn-reset {
            background: #4299e1;
            color: white;
            grid-column: span 2;
        }

        .btn-reset:hover {
            background: #3182ce;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(66, 153, 225, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .info-panel {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            margin-top: 20px;
        }

        .info-panel h3 {
            margin-top: 0;
            color: #2d3748;
            font-size: 16px;
        }

        .info-panel p {
            margin: 5px 0;
            color: #4a5568;
            font-size: 14px;
        }

        .legend {
            margin-top: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
        }

        .legend h3 {
            margin-top: 0;
            font-size: 16px;
            color: #2d3748;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 14px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 10px;
        }

        .instructions {
            background: #edf2f7;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-size: 14px;
            color: #2d3748;
        }

        .instructions strong {
            color: #667eea;
        }

        .footer {
            background: #343a40;
            color: white;
            text-align: center;
            padding: 20px;
            font-size: 14px;
        }

        .footer p {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé¢ Gradijentni Spust sa Momentumom</h1>
        <p class="subtitle">Interaktivna vizualizacija optimizacije funkcija jedne varijable</p>

        <div class="content">
            <div class="canvas-container">
                <canvas id="canvas" width="800" height="600"></canvas>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Funkcija</label>
                    <select id="functionSelect">
                        <option value="multimodal">Multimodalna (5 lokalnih minimuma)</option>
                        <option value="rastrigin">Rastrigin (periodiƒçni minimumi)</option>
                        <option value="ackley">Ackley (mnogo plitkih minimuma)</option>
                        <option value="sincos">Sin/Cos kombinacija</option>
                        <option value="bumpy">Bumpy funkcija (nepravilni minimumi)</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>
                        Momentum (Œ±)
                        <span class="value-display" id="momentumValue">0.00</span>
                    </label>
                    <input type="range" id="momentumSlider" min="0" max="99" value="0" step="1">
                </div>

                <div class="control-group">
                    <label>
                        Brzina uƒçenja (Œ∑)
                        <span class="value-display" id="learningRateValue">0.01</span>
                    </label>
                    <input type="range" id="learningRateSlider" min="1" max="50" value="10" step="1">
                </div>

                <div class="control-group">
                    <label>
                        Brzina demonstracije
                        <span class="value-display" id="speedValue">Srednja</span>
                    </label>
                    <input type="range" id="speedSlider" min="1" max="5" value="3" step="1">
                </div>

                <div class="button-group">
                    <button class="btn-start" id="startBtn">‚ñ∂ Start</button>
                    <button class="btn-stop" id="stopBtn" disabled>‚è∏ Stop</button>
                </div>
                <div class="button-group">
                    <button class="btn-start" id="stepBtn">‚è© Korak</button>
                    <button class="btn-reset" id="resetBtn">‚Üª Reset</button>
                </div>

                <div class="info-panel">
                    <h3>üìä Statistika</h3>
                    <p><strong>Iteracija:</strong> <span id="iterationCount">0</span></p>
                    <p><strong>Pozicija (x):</strong> <span id="posX">0</span></p>
                    <p><strong>Vrijednost funkcije:</strong> <span id="funcValue">0</span></p>
                    <p><strong>Gradijent:</strong> <span id="gradientMag">0</span></p>
                    <p><strong>Brzina:</strong> <span id="velocityMag">0</span></p>
                </div>

                <div class="legend">
                    <h3>üé® Legenda</h3>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #2563eb;"></div>
                        <span>Grafik funkcije</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f59e0b; border: 2px solid white;"></div>
                        <span>Trenutna pozicija</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: rgba(220,38,38,0.6);"></div>
                        <span>Putanja optimizacije</span>
                    </div>
                </div>

                <div class="instructions">
                    <strong>Kako koristiti:</strong><br>
                    1. Odaberite funkciju za optimizaciju<br>
                    2. Kliknite na grafik da postavite poƒçetnu taƒçku<br>
                    3. Podesite momentum (0 = bez momentuma) i brzinu uƒçenja<br>
                    4. Koristite "Start" za automatsko izvr≈°avanje ili "Korak" za izvr≈°avanje korak po korak<br>
                    <br>
                    <strong>Napomena:</strong> Bez momentuma, pretra≈æivanje se zaustavlja u lokalnom minimumu. Sa momentumom, mo≈æe proƒái preko plitkih lokalnih minimuma!
                </div>
            </div>
        </div>

        <div class="footer">
            <p><strong>Ma≈°insko uƒçenje i inteligentno upravljanje</strong></p>
            <p>Red. prof. dr Samim Konjicija, 2025.</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // State
        let position = 0;  // Only x position now
        let velocity = 0;  // Only x velocity now
        let isRunning = false;
        let iteration = 0;
        let path = [];
        let animationId = null;
        let currentFunction = 'multimodal';
        let momentum = 0;
        let learningRate = 0.01;
        let speed = 3;
        let lastGradient = 0;

        // Domain ranges for different functions
        const domains = {
            multimodal: { min: -10, max: 10 },
            rastrigin: { min: -5, max: 5 },
            ackley: { min: -5, max: 5 },
            sincos: { min: -10, max: 10 },
            bumpy: { min: -8, max: 8 }
        };

        // Test functions (1D)
        const functions = {
            multimodal: (x) => {
                // Function with multiple local minima
                return 0.5 * x * Math.sin(x) + 0.1 * x * x +
                       2 * Math.sin(2 * x) + Math.cos(3 * x);
            },

            rastrigin: (x) => {
                const A = 10;
                return A + x*x - A * Math.cos(2 * Math.PI * x);
            },

            ackley: (x) => {
                const a = 20, b = 0.2, c = 2 * Math.PI;
                return -a * Math.exp(-b * Math.abs(x)) -
                       Math.exp(Math.cos(c*x)) + a + Math.E;
            },

            sincos: (x) => {
                // Combination of sine and cosine
                return Math.sin(x) * Math.cos(x/2) + 0.05 * x * x;
            },

            bumpy: (x) => {
                // Bumpy function with irregular local minima
                return x * Math.sin(3 * x) + 0.5 * Math.sin(5 * x) +
                       0.1 * x * x + 2 * Math.sin(x);
            }
        };

        // Gradient function (numerical approximation) - 1D
        function gradient(func, x) {
            const h = 0.0001;
            const dfdx = (func(x + h) - func(x - h)) / (2 * h);
            return dfdx;
        }

        // Convert canvas X coordinate to function domain
        function canvasXToWorld(canvasX) {
            const domain = domains[currentFunction];
            const x = domain.min + (canvasX / canvas.width) * (domain.max - domain.min);
            return x;
        }

        // Convert function domain X to canvas X coordinate
        function worldXToCanvas(x) {
            const domain = domains[currentFunction];
            const canvasX = ((x - domain.min) / (domain.max - domain.min)) * canvas.width;
            return canvasX;
        }

        // Convert function value to canvas Y coordinate
        function valueToCanvasY(value, minVal, maxVal) {
            const padding = 50;
            const availableHeight = canvas.height - 2 * padding;
            const normalized = (value - minVal) / (maxVal - minVal);
            return canvas.height - padding - normalized * availableHeight;
        }

        // Draw function graph
        function drawFunctionGraph() {
            const resolution = 1000;
            const domain = domains[currentFunction];
            const func = functions[currentFunction];

            // Calculate function values and find min/max
            let minVal = Infinity;
            let maxVal = -Infinity;
            const points = [];

            for (let i = 0; i < resolution; i++) {
                const x = domain.min + (i / resolution) * (domain.max - domain.min);
                const val = func(x);
                points.push({ x, val });
                minVal = Math.min(minVal, val);
                maxVal = Math.max(maxVal, val);
            }

            // Add some padding to the range
            const range = maxVal - minVal;
            minVal -= range * 0.1;
            maxVal += range * 0.1;

            // Draw gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#ffe6e6');
            gradient.addColorStop(0.5, '#fff4e6');
            gradient.addColorStop(1, '#e6ffe6');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = (i / 10) * canvas.width;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();

                const y = (i / 10) * canvas.height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw function curve
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 3;
            ctx.beginPath();

            for (let i = 0; i < points.length; i++) {
                const canvasX = worldXToCanvas(points[i].x);
                const canvasY = valueToCanvasY(points[i].val, minVal, maxVal);

                if (i === 0) {
                    ctx.moveTo(canvasX, canvasY);
                } else {
                    ctx.lineTo(canvasX, canvasY);
                }
            }

            ctx.stroke();

            // Fill area under curve
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            ctx.fillStyle = 'rgba(37, 99, 235, 0.1)';
            ctx.fill();

            return { minVal, maxVal };
        }

        // Draw path
        function drawPath(minVal, maxVal) {
            if (path.length < 2) return;

            ctx.strokeStyle = 'rgba(220, 38, 38, 0.6)';
            ctx.lineWidth = 2;
            ctx.beginPath();

            const firstPoint = {
                x: worldXToCanvas(path[0].x),
                y: valueToCanvasY(path[0].val, minVal, maxVal)
            };
            ctx.moveTo(firstPoint.x, firstPoint.y);

            for (let i = 1; i < path.length; i++) {
                const point = {
                    x: worldXToCanvas(path[i].x),
                    y: valueToCanvasY(path[i].val, minVal, maxVal)
                };
                ctx.lineTo(point.x, point.y);
            }

            ctx.stroke();

            // Draw path points
            ctx.fillStyle = 'rgba(220, 38, 38, 0.4)';
            for (let i = 0; i < path.length; i++) {
                const point = {
                    x: worldXToCanvas(path[i].x),
                    y: valueToCanvasY(path[i].val, minVal, maxVal)
                };
                ctx.beginPath();
                ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        // Draw ball at current position
        function drawBall(minVal, maxVal) {
            const func = functions[currentFunction];
            const canvasX = worldXToCanvas(position);
            const canvasY = valueToCanvasY(func(position), minVal, maxVal);

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(canvasX + 2, canvasY + 2, 15, 0, 2 * Math.PI);
            ctx.fill();

            // Ball
            const gradient = ctx.createRadialGradient(
                canvasX - 5, canvasY - 5, 2,
                canvasX, canvasY, 15
            );
            gradient.addColorStop(0, '#fbbf24');
            gradient.addColorStop(1, '#f59e0b');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(canvasX, canvasY, 15, 0, 2 * Math.PI);
            ctx.fill();

            // Highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(canvasX - 5, canvasY - 5, 5, 0, 2 * Math.PI);
            ctx.fill();

            // Border
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(canvasX, canvasY, 15, 0, 2 * Math.PI);
            ctx.stroke();
        }

        // Render
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const { minVal, maxVal } = drawFunctionGraph();
            drawPath(minVal, maxVal);
            drawBall(minVal, maxVal);
            updateStats();
        }

        // Update statistics display
        function updateStats() {
            document.getElementById('iterationCount').textContent = iteration;
            document.getElementById('posX').textContent = position.toFixed(4);

            const funcValue = functions[currentFunction](position);
            document.getElementById('funcValue').textContent = funcValue.toFixed(4);

            document.getElementById('gradientMag').textContent = Math.abs(lastGradient).toFixed(6);
            document.getElementById('velocityMag').textContent = Math.abs(velocity).toFixed(6);
        }

        // Gradient descent step
        function step() {
            const func = functions[currentFunction];
            const grad = gradient(func, position);
            lastGradient = grad;

            // Update velocity with momentum
            velocity = momentum * velocity - learningRate * grad;

            // Update position
            position += velocity;

            // Keep within bounds
            const domain = domains[currentFunction];
            position = Math.max(domain.min, Math.min(domain.max, position));

            // Add to path
            path.push({ x: position, val: func(position) });

            iteration++;
        }

        // Animation loop
        let lastFrameTime = 0;
        function animate(currentTime) {
            if (!isRunning) return;

            // Control animation speed with delay
            const delays = [500, 300, 150, 80, 40]; // milliseconds between frames
            const delay = delays[speed - 1];

            if (currentTime - lastFrameTime < delay) {
                animationId = requestAnimationFrame(animate);
                return;
            }
            lastFrameTime = currentTime;

            // Perform one step
            step();

            // Stop if gradient is very small (converged to local minimum)
            // When there's no momentum, this ensures we stop at local minimum
            if (Math.abs(lastGradient) < 1e-4) {
                stop();
                render();
                return;
            }

            // Stop after max iterations
            if (iteration > 5000) {
                stop();
                render();
                return;
            }

            render();
            animationId = requestAnimationFrame(animate);
        }

        // Start optimization
        function start() {
            if (path.length === 0) {
                alert('Kliknite na canvas da postavite poƒçetnu taƒçku!');
                return;
            }

            isRunning = true;
            lastFrameTime = 0;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('stepBtn').disabled = true;
            animationId = requestAnimationFrame(animate);
        }

        // Stop optimization
        function stop() {
            isRunning = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('stepBtn').disabled = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }

        // Single step
        function singleStep() {
            if (path.length === 0) {
                alert('Kliknite na canvas da postavite poƒçetnu taƒçku!');
                return;
            }

            step();
            render();

            // Check stopping conditions
            if (Math.abs(lastGradient) < 1e-4) {
                alert('Dostignut lokalni minimum (gradijent ‚âà 0)');
            }
        }

        // Reset
        function reset() {
            stop();
            path = [];
            velocity = 0;
            iteration = 0;
            lastGradient = 0;

            // Set default position
            const domain = domains[currentFunction];
            position = domain.min + 0.3 * (domain.max - domain.min);
            const func = functions[currentFunction];
            path.push({ x: position, val: func(position) });

            render();
        }

        // Event listeners
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;

            position = canvasXToWorld(canvasX);
            velocity = 0;
            const func = functions[currentFunction];
            path = [{ x: position, val: func(position) }];
            iteration = 0;
            lastGradient = 0;

            stop();
            render();
        });

        document.getElementById('functionSelect').addEventListener('change', (e) => {
            currentFunction = e.target.value;
            reset();
        });

        document.getElementById('momentumSlider').addEventListener('input', (e) => {
            momentum = e.target.value / 100;
            document.getElementById('momentumValue').textContent = momentum.toFixed(2);
        });

        document.getElementById('learningRateSlider').addEventListener('input', (e) => {
            learningRate = e.target.value / 1000;
            document.getElementById('learningRateValue').textContent = learningRate.toFixed(3);
        });

        document.getElementById('speedSlider').addEventListener('input', (e) => {
            speed = parseInt(e.target.value);
            const speedLabels = ['Vrlo sporo', 'Sporo', 'Srednje', 'Brzo', 'Vrlo brzo'];
            document.getElementById('speedValue').textContent = speedLabels[speed - 1];
        });

        document.getElementById('startBtn').addEventListener('click', start);
        document.getElementById('stopBtn').addEventListener('click', stop);
        document.getElementById('stepBtn').addEventListener('click', singleStep);
        document.getElementById('resetBtn').addEventListener('click', reset);

        // Initialize
        reset();
    </script>
</body>
</html>
