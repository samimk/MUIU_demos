<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transformacija prostora kroz skrivene slojeve - Neural Network Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2em;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 20px;
            font-size: 1.1em;
        }

        .network-architecture {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .network-architecture h2 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 1.3em;
        }

        .architecture-diagram {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 40px;
            margin: 20px 0;
        }

        .layer-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .layer-title {
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .neurons {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .neuron {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .connections {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            height: 115px;
            position: relative;
        }

        .arrow {
            color: #999;
            font-size: 2em;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 30px;
        }
        
        .controls {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            height: fit-content;
        }
        
        .control-group {
            margin-bottom: 25px;
        }
        
        .control-group h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.1em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
        }
        
        .control-item {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            color: #555;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        select, input[type="range"] {
            width: 100%;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        
        input[type="range"] {
            padding: 0;
        }
        
        .value-display {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            margin-left: 10px;
        }
        
        button {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: transform 0.2s;
            margin-top: 10px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .visualization {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .layer-row {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .layer-label {
            min-width: 120px;
            font-weight: bold;
            color: #333;
            text-align: right;
        }
        
        .canvas-container {
            flex: 1;
            border: 3px solid #ddd;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        canvas {
            display: block;
        }
        
        .info-box {
            background: #e8eaf6;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            border-left: 4px solid #667eea;
        }
        
        .info-box h4 {
            color: #333;
            margin-bottom: 10px;
        }
        
        .info-box p {
            color: #555;
            line-height: 1.6;
            font-size: 14px;
        }
        
        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 30px;
            height: 20px;
            border-radius: 4px;
            border: 2px solid #333;
        }
        
        .footer {
            background: #343a40;
            color: white;
            text-align: center;
            padding: 20px;
            font-size: 14px;
        }

        .footer p {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß† Transformacija prostora kroz skrivene slojeve</h1>
        <p class="subtitle">Interaktivna vizualizacija kako neuronska mre≈æa transformira ulazni prostor</p>

        <div class="network-architecture">
            <h2>üìê Arhitektura mre≈æe</h2>
            <div class="architecture-diagram">
                <div class="layer-group">
                    <div class="layer-title">Ulazni sloj</div>
                    <div class="neurons">
                        <div class="neuron">x‚ÇÅ</div>
                        <div class="neuron">x‚ÇÇ</div>
                    </div>
                </div>
                <div class="connections">
                    <span class="arrow">‚Üí</span>
                    <span class="arrow">‚Üí</span>
                </div>
                <div class="layer-group">
                    <div class="layer-title">Skriveni sloj (2 neurona)</div>
                    <div class="neurons">
                        <div class="neuron">h‚ÇÅ</div>
                        <div class="neuron">h‚ÇÇ</div>
                    </div>
                </div>
                <div class="connections">
                    <span class="arrow">‚Üí</span>
                </div>
                <div class="layer-group">
                    <div class="layer-title">Izlazni sloj</div>
                    <div class="neurons">
                        <div class="neuron">y</div>
                    </div>
                </div>
            </div>
            <div style="text-align: center; color: #666; font-size: 0.9em; margin-top: 15px;">
                2 ulaza ‚Üí 2 skrivena neurona ‚Üí 1 izlaz (binarna klasifikacija)
            </div>
        </div>

        <div class="main-content">
            <div class="controls">
                <div class="control-group">
                    <h3>üìä Problem</h3>
                    <div class="control-item">
                        <label for="dataset">Dataset:</label>
                        <select id="dataset">
                            <option value="xor">XOR (nelinearno razdvojiv)</option>
                            <option value="circle">Kru≈æni (radijalno razdvojiv)</option>
                            <option value="spiral">Spirala (vrlo kompleksan)</option>
                            <option value="linear">Linearno razdvojiv</option>
                        </select>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>üèóÔ∏è Arhitektura</h3>
                    <div class="control-item">
                        <label>Broj neurona u skrivenom sloju: <span class="value-display">2 (fiksno)</span></label>
                    </div>
                    <div class="control-item">
                        <label for="activation">Aktivacijska funkcija:</label>
                        <select id="activation">
                            <option value="tanh">tanh (preporuƒçeno)</option>
                            <option value="sigmoid">sigmoid</option>
                            <option value="relu">ReLU</option>
                        </select>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>üéì Treniranje</h3>
                    <div class="control-item">
                        <label for="learningRate">Brzina uƒçenja: <span class="value-display" id="lrValue">0.1</span></label>
                        <input type="range" id="learningRate" min="0.01" max="0.5" step="0.01" value="0.1">
                    </div>
                    <button id="trainBtn">‚ñ∂Ô∏è Treniraj 100 epoha</button>
                    <button id="resetBtn">üîÑ Resetuj mre≈æu</button>
                </div>
                
                <div class="info-box">
                    <h4>üí° Kako koristiti:</h4>
                    <p>
                        1. Izaberite dataset (XOR je klasiƒçan primjer)<br>
                        2. Podesite broj neurona<br>
                        3. Kliknite "Treniraj"<br>
                        4. Posmatrajte kako se prostor transformira kroz slojeve!
                    </p>
                </div>
                
                <div class="info-box" style="margin-top: 10px;">
                    <h4>üéØ ≈†ta vidite:</h4>
                    <p>
                        <strong>1. Ulazni prostor:</strong> Originalni (x‚ÇÅ, x‚ÇÇ) podaci<br>
                        <strong>2. Skriveni - Linear:</strong> z = W‚ÇÅx + b‚ÇÅ (linearna transformacija)<br>
                        <strong>3. Skriveni - Aktivacija:</strong> a = œÉ(z) (nelinearna transformacija)<br>
                        <strong>4. Izlaz - Linear:</strong> z‚ÇÇ = W‚ÇÇa + b‚ÇÇ (prije finalne aktivacije)<br>
                        <strong>5. Izlaz - Aktivacija:</strong> y = sigmoid(z‚ÇÇ) (finalna klasifikacija)
                    </p>
                </div>
            </div>
            
            <div class="visualization">
                <div class="layer-row">
                    <div class="layer-label">1. Ulazni prostor<br>(x‚ÇÅ, x‚ÇÇ)</div>
                    <div class="canvas-container">
                        <canvas id="inputCanvas" width="400" height="400"></canvas>
                    </div>
                </div>

                <div class="layer-row">
                    <div class="layer-label">2. Skriveni - Linear<br>z = W‚ÇÅx + b‚ÇÅ</div>
                    <div class="canvas-container">
                        <canvas id="hiddenLinearCanvas" width="400" height="400"></canvas>
                    </div>
                </div>

                <div class="layer-row">
                    <div class="layer-label">3. Skriveni - Aktivacija<br>a = œÉ(z)</div>
                    <div class="canvas-container">
                        <canvas id="hiddenActivatedCanvas" width="400" height="400"></canvas>
                    </div>
                </div>

                <div class="layer-row">
                    <div class="layer-label">4. Izlaz - Linear<br>z‚ÇÇ = W‚ÇÇa + b‚ÇÇ</div>
                    <div class="canvas-container">
                        <canvas id="outputLinearCanvas" width="400" height="400"></canvas>
                    </div>
                </div>

                <div class="layer-row">
                    <div class="layer-label">5. Izlaz - Aktivacija<br>y = sigmoid(z‚ÇÇ)</div>
                    <div class="canvas-container">
                        <canvas id="outputCanvas" width="400" height="400"></canvas>
                    </div>
                </div>
                
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: rgba(255, 100, 100, 0.7);"></div>
                        <span>Klasa 0 (crvena)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: rgba(100, 100, 255, 0.7);"></div>
                        <span>Klasa 1 (plava)</span>
                    </div>
                    <div class="legend-item">
                        <span>Veliƒçina taƒçke = sigurnost klasifikacije</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="footer">
            <p><strong>Ma≈°insko uƒçenje i inteligentno upravljanje</strong></p>
            <p>Red. prof. dr Samim Konjicija, 2025.</p>
        </div>
    </div>

    <script>
        // Neural Network implementation
        class NeuralNetwork {
            constructor(inputSize, hiddenSize, outputSize, activationFunc) {
                this.inputSize = inputSize;
                this.hiddenSize = hiddenSize;
                this.outputSize = outputSize;
                this.activationFunc = activationFunc;
                this.reset();
            }
            
            reset() {
                // Initialize weights with small random values
                this.W1 = this.randomMatrix(this.hiddenSize, this.inputSize, -0.5, 0.5);
                this.b1 = this.randomMatrix(this.hiddenSize, 1, -0.2, 0.2);
                this.W2 = this.randomMatrix(this.outputSize, this.hiddenSize, -0.5, 0.5);
                this.b2 = this.randomMatrix(this.outputSize, 1, -0.2, 0.2);
            }
            
            randomMatrix(rows, cols, min, max) {
                const matrix = [];
                for (let i = 0; i < rows; i++) {
                    matrix[i] = [];
                    for (let j = 0; j < cols; j++) {
                        matrix[i][j] = Math.random() * (max - min) + min;
                    }
                }
                return matrix;
            }
            
            activate(x, derivative = false) {
                switch(this.activationFunc) {
                    case 'tanh':
                        if (derivative) {
                            const t = Math.tanh(x);
                            return 1 - t * t;
                        }
                        return Math.tanh(x);
                    case 'sigmoid':
                        const sig = 1 / (1 + Math.exp(-x));
                        return derivative ? sig * (1 - sig) : sig;
                    case 'relu':
                        return derivative ? (x > 0 ? 1 : 0) : Math.max(0, x);
                }
            }
            
            forward(input) {
                // Store for visualization
                this.input = input;
                
                // Hidden layer (linear transformation)
                this.z1 = [];
                for (let i = 0; i < this.hiddenSize; i++) {
                    let sum = this.b1[i][0];
                    for (let j = 0; j < this.inputSize; j++) {
                        sum += this.W1[i][j] * input[j];
                    }
                    this.z1[i] = sum;
                }
                
                // Apply activation
                this.a1 = this.z1.map(z => this.activate(z));
                
                // Output layer
                this.z2 = [];
                for (let i = 0; i < this.outputSize; i++) {
                    let sum = this.b2[i][0];
                    for (let j = 0; j < this.hiddenSize; j++) {
                        sum += this.W2[i][j] * this.a1[j];
                    }
                    this.z2[i] = sum;
                }
                
                // Output activation (sigmoid for binary classification)
                this.output = 1 / (1 + Math.exp(-this.z2[0]));
                
                return this.output;
            }
            
            train(inputs, targets, learningRate, epochs) {
                for (let epoch = 0; epoch < epochs; epoch++) {
                    for (let i = 0; i < inputs.length; i++) {
                        this.trainOne(inputs[i], targets[i], learningRate);
                    }
                }
            }
            
            trainOne(input, target, learningRate) {
                // Forward pass
                this.forward(input);
                
                // Output layer error
                const outputError = this.output - target;
                const outputDelta = outputError; // derivative of sigmoid already computed in output
                
                // Hidden layer error
                const hiddenError = [];
                for (let i = 0; i < this.hiddenSize; i++) {
                    let error = 0;
                    for (let j = 0; j < this.outputSize; j++) {
                        error += this.W2[j][i] * outputDelta;
                    }
                    hiddenError[i] = error;
                }
                
                const hiddenDelta = hiddenError.map((e, i) => e * this.activate(this.z1[i], true));
                
                // Update output layer weights
                for (let i = 0; i < this.outputSize; i++) {
                    for (let j = 0; j < this.hiddenSize; j++) {
                        this.W2[i][j] -= learningRate * outputDelta * this.a1[j];
                    }
                    this.b2[i][0] -= learningRate * outputDelta;
                }
                
                // Update hidden layer weights
                for (let i = 0; i < this.hiddenSize; i++) {
                    for (let j = 0; j < this.inputSize; j++) {
                        this.W1[i][j] -= learningRate * hiddenDelta[i] * input[j];
                    }
                    this.b1[i][0] -= learningRate * hiddenDelta[i];
                }
            }
        }
        
        // Dataset generators
        function generateXOR(n = 100) {
            const data = [];
            for (let i = 0; i < n; i++) {
                const x1 = Math.random() * 2 - 1;
                const x2 = Math.random() * 2 - 1;
                const label = (x1 > 0) !== (x2 > 0) ? 1 : 0;
                data.push({x: [x1, x2], y: label});
            }
            return data;
        }
        
        function generateCircle(n = 100) {
            const data = [];
            for (let i = 0; i < n; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * 0.8 + 0.2;
                const x1 = r * Math.cos(angle);
                const x2 = r * Math.sin(angle);
                const label = r > 0.5 ? 1 : 0;
                data.push({x: [x1, x2], y: label});
            }
            return data;
        }
        
        function generateSpiral(n = 100) {
            const data = [];
            for (let i = 0; i < n / 2; i++) {
                const angle = i / (n/2) * Math.PI * 3;
                const r = i / (n/2) * 0.8;
                
                // Spiral 1
                const x1_1 = r * Math.cos(angle) + (Math.random() - 0.5) * 0.1;
                const x2_1 = r * Math.sin(angle) + (Math.random() - 0.5) * 0.1;
                data.push({x: [x1_1, x2_1], y: 0});
                
                // Spiral 2
                const x1_2 = r * Math.cos(angle + Math.PI) + (Math.random() - 0.5) * 0.1;
                const x2_2 = r * Math.sin(angle + Math.PI) + (Math.random() - 0.5) * 0.1;
                data.push({x: [x1_2, x2_2], y: 1});
            }
            return data;
        }
        
        function generateLinear(n = 100) {
            const data = [];
            for (let i = 0; i < n; i++) {
                const x1 = Math.random() * 2 - 1;
                const x2 = Math.random() * 2 - 1;
                const label = x1 + x2 > 0 ? 1 : 0;
                data.push({x: [x1, x2], y: label});
            }
            return data;
        }
        
        // Visualization
        class Visualizer {
            constructor() {
                this.canvases = {
                    input: document.getElementById('inputCanvas'),
                    hiddenLinear: document.getElementById('hiddenLinearCanvas'),
                    hiddenActivated: document.getElementById('hiddenActivatedCanvas'),
                    outputLinear: document.getElementById('outputLinearCanvas'),
                    output: document.getElementById('outputCanvas')
                };

                this.contexts = {
                    input: this.canvases.input.getContext('2d'),
                    hiddenLinear: this.canvases.hiddenLinear.getContext('2d'),
                    hiddenActivated: this.canvases.hiddenActivated.getContext('2d'),
                    outputLinear: this.canvases.outputLinear.getContext('2d'),
                    output: this.canvases.output.getContext('2d')
                };

                this.gridResolution = 40;
                this.bounds = {}; // Store bounds for each layer
            }

            computeBounds(transformedData) {
                // Initialize bounds for each layer
                const bounds = {
                    input: { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity },
                    hiddenLinear: { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity },
                    hiddenActivated: { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity },
                    outputLinear: { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity },
                    output: { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity }
                };

                transformedData.forEach(point => {
                    // Input bounds
                    bounds.input.minX = Math.min(bounds.input.minX, point.input[0]);
                    bounds.input.maxX = Math.max(bounds.input.maxX, point.input[0]);
                    bounds.input.minY = Math.min(bounds.input.minY, point.input[1]);
                    bounds.input.maxY = Math.max(bounds.input.maxY, point.input[1]);

                    // Hidden linear bounds
                    bounds.hiddenLinear.minX = Math.min(bounds.hiddenLinear.minX, point.z1[0]);
                    bounds.hiddenLinear.maxX = Math.max(bounds.hiddenLinear.maxX, point.z1[0]);
                    bounds.hiddenLinear.minY = Math.min(bounds.hiddenLinear.minY, point.z1[1]);
                    bounds.hiddenLinear.maxY = Math.max(bounds.hiddenLinear.maxY, point.z1[1]);

                    // Hidden activated bounds
                    bounds.hiddenActivated.minX = Math.min(bounds.hiddenActivated.minX, point.a1[0]);
                    bounds.hiddenActivated.maxX = Math.max(bounds.hiddenActivated.maxX, point.a1[0]);
                    bounds.hiddenActivated.minY = Math.min(bounds.hiddenActivated.minY, point.a1[1]);
                    bounds.hiddenActivated.maxY = Math.max(bounds.hiddenActivated.maxY, point.a1[1]);

                    // Output linear bounds
                    const avgX = (point.input[0] + point.input[1]) / 2;
                    bounds.outputLinear.minX = Math.min(bounds.outputLinear.minX, avgX);
                    bounds.outputLinear.maxX = Math.max(bounds.outputLinear.maxX, avgX);
                    bounds.outputLinear.minY = Math.min(bounds.outputLinear.minY, point.z2);
                    bounds.outputLinear.maxY = Math.max(bounds.outputLinear.maxY, point.z2);

                    // Output bounds (same as input)
                    bounds.output.minX = Math.min(bounds.output.minX, point.input[0]);
                    bounds.output.maxX = Math.max(bounds.output.maxX, point.input[0]);
                    bounds.output.minY = Math.min(bounds.output.minY, point.input[1]);
                    bounds.output.maxY = Math.max(bounds.output.maxY, point.input[1]);
                });

                // Add padding (10% on each side)
                Object.keys(bounds).forEach(layer => {
                    const rangeX = bounds[layer].maxX - bounds[layer].minX;
                    const rangeY = bounds[layer].maxY - bounds[layer].minY;
                    const paddingX = rangeX * 0.1;
                    const paddingY = rangeY * 0.1;

                    bounds[layer].minX -= paddingX;
                    bounds[layer].maxX += paddingX;
                    bounds[layer].minY -= paddingY;
                    bounds[layer].maxY += paddingY;

                    // Calculate scale factors
                    bounds[layer].scaleX = 400 / (bounds[layer].maxX - bounds[layer].minX);
                    bounds[layer].scaleY = 400 / (bounds[layer].maxY - bounds[layer].minY);
                });

                return bounds;
            }
            
            clear() {
                Object.values(this.contexts).forEach(ctx => {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, 400, 400);
                });
            }
            
            drawData(data, nn) {
                this.clear();

                // First, compute all transformations for all points
                const transformedData = data.map(point => {
                    nn.forward(point.x);
                    return {
                        input: point.x,
                        label: point.y,
                        z1: [nn.z1[0], nn.z1[1]],
                        a1: [nn.a1[0], nn.a1[1]],
                        z2: nn.z2[0], // Output before activation
                        output: nn.output
                    };
                });

                // Compute dynamic bounds for all layers
                this.bounds = this.computeBounds(transformedData);

                // Draw decision boundaries for each space
                this.drawDecisionBoundary(this.contexts.input, nn, 'input', transformedData);
                this.drawDecisionBoundary(this.contexts.hiddenLinear, nn, 'hiddenLinear', transformedData);
                this.drawDecisionBoundary(this.contexts.hiddenActivated, nn, 'hiddenActivated', transformedData);
                this.drawDecisionBoundary(this.contexts.outputLinear, nn, 'outputLinear', transformedData);
                this.drawDecisionBoundary(this.contexts.output, nn, 'output', transformedData);

                // Draw data points in each transformed space
                transformedData.forEach(point => {
                    // Input space: show original coordinates
                    this.drawPoint(this.contexts.input, 'input', point.input, point.input, point.label);

                    // Hidden linear: show z1 coordinates (before activation)
                    this.drawPoint(this.contexts.hiddenLinear, 'hiddenLinear', point.input, point.z1, point.label);

                    // Hidden activated: show a1 coordinates (after activation)
                    this.drawPoint(this.contexts.hiddenActivated, 'hiddenActivated', point.input, point.a1, point.label);

                    // Output linear: show z2 as 1D value (we'll map it to y-axis)
                    // For visualization, we use (x, z2) where x is average of input
                    const avgX = (point.input[0] + point.input[1]) / 2;
                    this.drawPoint(this.contexts.outputLinear, 'outputLinear', point.input, [avgX, point.z2], point.label);

                    // Output: show back in input space, colored by prediction
                    this.drawPoint(this.contexts.output, 'output', point.input, point.input,
                                 point.output > 0.5 ? 1 : 0, point.output);
                });
            }
            
            drawPoint(ctx, layer, originalCoords, coords, label, confidence = null) {
                // Get bounds for this layer
                const bounds = this.bounds[layer];
                if (!bounds) return;

                // Map coordinates to canvas space using layer-specific bounds
                const x = (coords[0] - bounds.minX) * bounds.scaleX;
                const y = 400 - (coords[1] - bounds.minY) * bounds.scaleY;

                // Skip if out of bounds
                if (x < 0 || x > 400 || y < 0 || y > 400) return;

                // Calculate size based on confidence if provided
                let size = 5;
                if (confidence !== null) {
                    const certainty = Math.abs(confidence - 0.5) * 2;
                    size = 3 + certainty * 4;
                }

                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fillStyle = label === 1 ? 'rgba(100, 100, 255, 0.8)' : 'rgba(255, 100, 100, 0.8)';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }
            
            drawDecisionBoundary(ctx, nn, layer, transformedData) {
                const imageData = ctx.createImageData(400, 400);
                const bounds = this.bounds[layer];
                if (!bounds) return;

                for (let px = 0; px < 400; px++) {
                    for (let py = 0; py < 400; py++) {
                        let value;

                        // Convert pixel coordinates to data coordinates using bounds
                        const dataX = bounds.minX + (px / bounds.scaleX);
                        const dataY = bounds.maxY - (py / bounds.scaleY);

                        if (layer === 'input' || layer === 'output') {
                            // For input/output: use original coordinate space
                            nn.forward([dataX, dataY]);
                            value = nn.output;

                        } else if (layer === 'hiddenLinear') {
                            // For hidden linear: interpret pixel as (z1, z2) coordinates
                            // and compute what the output layer would predict
                            const z1 = dataX;
                            const z2 = dataY;

                            // Apply activation to get a1
                            const a1 = [nn.activate(z1), nn.activate(z2)];

                            // Compute output from hidden activation
                            let z2_out = nn.b2[0][0];
                            for (let j = 0; j < 2; j++) {
                                z2_out += nn.W2[0][j] * a1[j];
                            }
                            value = 1 / (1 + Math.exp(-z2_out));

                        } else if (layer === 'hiddenActivated') {
                            // For hidden activated: interpret pixel as (a1[0], a1[1]) coordinates
                            const a1_0 = dataX;
                            const a1_1 = dataY;

                            // Compute output from these activations
                            let z2_out = nn.b2[0][0];
                            z2_out += nn.W2[0][0] * a1_0;
                            z2_out += nn.W2[0][1] * a1_1;
                            value = 1 / (1 + Math.exp(-z2_out));

                        } else if (layer === 'outputLinear') {
                            // For output linear: interpret pixel as (avgX, z2) coordinates
                            // We show z2 value on y-axis, avgX on x-axis
                            const avgX = dataX;
                            const z2_val = dataY;

                            // Decision boundary is at z2 = 0 (which gives sigmoid(0) = 0.5)
                            // Color based on z2 value
                            value = 1 / (1 + Math.exp(-z2_val));
                        } else {
                            value = 0.5;
                        }

                        const idx = (py * 400 + px) * 4;
                        if (value > 0.5) {
                            imageData.data[idx] = 150;
                            imageData.data[idx + 1] = 150;
                            imageData.data[idx + 2] = 255;
                        } else {
                            imageData.data[idx] = 255;
                            imageData.data[idx + 1] = 150;
                            imageData.data[idx + 2] = 150;
                        }
                        imageData.data[idx + 3] = 30;
                    }
                }

                ctx.putImageData(imageData, 0, 0);

                // Draw grid and axes with dynamic bounds
                ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
                ctx.lineWidth = 1;

                // Calculate where zero axes should be (if in view)
                const zeroX = (0 - bounds.minX) * bounds.scaleX;
                const zeroY = 400 - (0 - bounds.minY) * bounds.scaleY;

                // Draw zero axes if they're in view
                if (zeroX >= 0 && zeroX <= 400) {
                    ctx.beginPath();
                    ctx.moveTo(zeroX, 0);
                    ctx.lineTo(zeroX, 400);
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                if (zeroY >= 0 && zeroY <= 400) {
                    ctx.beginPath();
                    ctx.moveTo(0, zeroY);
                    ctx.lineTo(400, zeroY);
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Grid lines
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.2)';
                ctx.lineWidth = 1;

                // Calculate grid spacing based on data range
                const rangeX = bounds.maxX - bounds.minX;
                const rangeY = bounds.maxY - bounds.minY;
                const gridSpacingX = Math.pow(10, Math.floor(Math.log10(rangeX / 4)));
                const gridSpacingY = Math.pow(10, Math.floor(Math.log10(rangeY / 4)));

                // Vertical grid lines
                const startGridX = Math.ceil(bounds.minX / gridSpacingX) * gridSpacingX;
                for (let gridX = startGridX; gridX <= bounds.maxX; gridX += gridSpacingX) {
                    const px = (gridX - bounds.minX) * bounds.scaleX;
                    if (px >= 0 && px <= 400) {
                        ctx.beginPath();
                        ctx.moveTo(px, 0);
                        ctx.lineTo(px, 400);
                        ctx.stroke();
                    }
                }

                // Horizontal grid lines
                const startGridY = Math.ceil(bounds.minY / gridSpacingY) * gridSpacingY;
                for (let gridY = startGridY; gridY <= bounds.maxY; gridY += gridSpacingY) {
                    const py = 400 - (gridY - bounds.minY) * bounds.scaleY;
                    if (py >= 0 && py <= 400) {
                        ctx.beginPath();
                        ctx.moveTo(0, py);
                        ctx.lineTo(400, py);
                        ctx.stroke();
                    }
                }
            }
        }
        
        // Main application
        let nn, data, visualizer;

        function init() {
            visualizer = new Visualizer();

            // Fixed to 2 hidden neurons for 2D visualization
            const hiddenNeurons = 2;
            const activation = document.getElementById('activation').value;

            nn = new NeuralNetwork(2, hiddenNeurons, 1, activation);

            const datasetType = document.getElementById('dataset').value;
            switch(datasetType) {
                case 'xor': data = generateXOR(150); break;
                case 'circle': data = generateCircle(150); break;
                case 'spiral': data = generateSpiral(150); break;
                case 'linear': data = generateLinear(150); break;
            }

            visualizer.drawData(data, nn);
        }

        document.getElementById('trainBtn').addEventListener('click', () => {
            const learningRate = parseFloat(document.getElementById('learningRate').value);
            const inputs = data.map(d => d.x);
            const targets = data.map(d => d.y);

            nn.train(inputs, targets, learningRate, 100);
            visualizer.drawData(data, nn);
        });

        document.getElementById('resetBtn').addEventListener('click', init);

        document.getElementById('dataset').addEventListener('change', init);
        document.getElementById('activation').addEventListener('change', init);
        document.getElementById('learningRate').addEventListener('input', function() {
            document.getElementById('lrValue').textContent = this.value;
        });

        // Initialize on load
        window.onload = init;
    </script>
</body>
</html>
